diff -u otftotfm.orig/dvipsencoding.cc otftotfm/dvipsencoding.cc
--- otftotfm.orig/dvipsencoding.cc	Fri Mar 11 03:41:56 2005
+++ otftotfm/dvipsencoding.cc	Wed Apr  6 08:31:07 2005
@@ -301,9 +301,30 @@
     for (int i = 0; ligkern_ops[i].s; i++)
 	if (ligkern_ops[i].s == s)
 	    return ligkern_ops[i].v;
+
+    if (s[0] == '{' && s.back() == '}' &&
+        (s[1] == '-' || isdigit(s[1]))) {
+        for (int i = 2; i < s.length() - 1; i++)
+            if (!isdigit(s[i]))
+                return -1;
+        return DvipsEncoding::J_KERN;
+    }
     return -1;
 }
 
+static long
+parse_kern_op(const String &s)
+{
+    if (s[0] == '{' && s.back() == '}') {
+        char *endptr;
+        long kern = strtol(s.data() + 1, &endptr, 10);
+
+        if (endptr == s.end() - 1)
+          return kern;
+    }
+    return 0;
+}
+
 inline bool
 operator==(const DvipsEncoding::Ligature& l1, const DvipsEncoding::Ligature& l2)
 {
@@ -349,6 +370,10 @@
 	    if (bv < 0)
 		return errh->warning("'%s' has no encoding, ignoring %s", v[2].c_str(), nokern_names[op - J_NOKERN]);
 	    Ligature lig = { av, bv, op, 0 };
+
+            if (op == J_KERN)
+              lig.d = parse_kern_op(v[1]);
+
 	    Ligature *what = std::find(_lig.begin(), _lig.end(), lig);
 	    if (override > 0 && what < _lig.end())
 		*what = lig;
@@ -698,6 +723,9 @@
 	} else if (l.join == J_CLIG) {
 	    metrics.remove_ligatures(l.c1, l.c2);
 	    metrics.add_ligature(l.c1, l.c2, metrics.pair_code(l.c1, l.d));
+	} else if (l.join == J_KERN) {
+	    metrics.remove_ligatures(l.c1, l.c2);
+	    metrics.add_kern(l.c1, l.c2, l.d);
 	} else {
 	    static int complex_join_warning = 0;
 	    if (!complex_join_warning) {
diff -u otftotfm.orig/dvipsencoding.hh otftotfm/dvipsencoding.hh
--- otftotfm.orig/dvipsencoding.hh	Fri Mar 11 03:41:07 2005
+++ otftotfm/dvipsencoding.hh	Wed Apr  6 08:30:01 2005
@@ -42,7 +42,7 @@
     enum { J_BAD = -1,
 	   J_LIG = 0, J_CLIG = 1, J_CLIG_S = 2, J_LIGC = 3,
 	   J_LIGC_S = 4, J_CLIGC = 5, J_CLIGC_S = 6, J_CLIGC_SS = 7,
-	   J_NOKERN = 100, J_NOLIG = 101, J_NOLIGKERN = 102,
+	   J_NOKERN = 100, J_NOLIG = 101, J_NOLIGKERN = 102, J_KERN = 103,
 	   J_ALL = 0x7FFFFFFF }; // also see nokern_names in dvipsencoding.cc
     
   private:
diff -u otftotfm.orig/metrics.cc otftotfm/metrics.cc
--- otftotfm.orig/metrics.cc	Sun Apr  3 04:25:04 2005
+++ otftotfm/metrics.cc	Wed Apr  6 08:30:01 2005
@@ -24,7 +24,7 @@
 #include <lcdf/straccum.hh>
 
 Metrics::Metrics(Efont::CharstringProgram *font, int nglyphs)
-    : _boundary_glyph(nglyphs), _emptyslot_glyph(nglyphs + 1),
+    : _boundary_glyph(nglyphs), _skew_glyph(nglyphs + 1), _emptyslot_glyph(nglyphs + 2),
       _design_units(1000), _liveness_marked(false)
 {
     _encoding.assign(256, Char());
@@ -97,6 +97,8 @@
 	    return ch.virtual_char->name;
 	else if (ch.glyph == _boundary_glyph)
 	    return "<boundary>";
+	else if (ch.glyph == _skew_glyph)
+	    return "<skew>";
 	else if (ch.glyph == _emptyslot_glyph)
 	    return "<emptyslot>";
 	else if (ch.glyph >= 0 && ch.glyph < _mapped_fonts[0]->nglyphs())
diff -u otftotfm.orig/metrics.hh otftotfm/metrics.hh
--- otftotfm.orig/metrics.hh	Tue Aug 10 09:27:30 2004
+++ otftotfm/metrics.hh	Wed Apr  6 08:30:01 2005
@@ -31,6 +31,7 @@
     void check() const;
     
     Glyph boundary_glyph() const	{ return _boundary_glyph; }
+    Glyph skew_glyph() const		{ return _skew_glyph; }
     Glyph emptyslot_glyph() const	{ return _emptyslot_glyph; }
 
     String coding_scheme() const		{ return _coding_scheme; }
@@ -147,6 +148,7 @@
     mutable Vector<int> _emap;
 
     Glyph _boundary_glyph;
+    Glyph _skew_glyph;
     Glyph _emptyslot_glyph;
 
     Vector<Kern> _altselectors;
diff -u otftotfm.orig/otftotfm.1 otftotfm/otftotfm.1
--- otftotfm.orig/otftotfm.1	Sun Apr  3 02:28:50 2005
+++ otftotfm/otftotfm.1	Wed Apr  6 08:30:01 2005
@@ -431,6 +431,13 @@
 such feature.
 .PD
 '
+.Sp
+.TP 5
+.BI \-\-extra\-skew= amount
+Increases the kerning with the skew character by
+.IR amount .
+This results in shifting accents in math mode to the left.
+'
 '
 .SS Encoding Options
 '
@@ -603,6 +610,18 @@
 .nf
     \fBotftotfm\fR \fB\-f\fRsalt \fB\-\-include\-alternates\fR='*.end' \fB\-f\fRaalt \.\.\.
 .fi
+'
+.Sp
+.TP 5
+.BI \-\-skew\-char= char
+Set the font's skew character to
+.IR char ,
+Computes kerning values for the skew character that determine accent
+positions in math mode. This option only works in conjunction with the
+.B \-\-math\-font
+option. You can use the
+.B \-\-extra\-skew
+option to further modify the accent positions.
 '
 .PD
 '
diff -u otftotfm.orig/otftotfm.cc otftotfm/otftotfm.cc
--- otftotfm.orig/otftotfm.cc	Sun Apr  3 04:25:24 2005
+++ otftotfm/otftotfm.cc	Wed Apr  6 08:30:01 2005
@@ -94,6 +94,8 @@
 #define ALTERNATES_FILTER_OPT	336
 #define SPACE_FACTOR_OPT	337
 #define MATH_SPACING_OPT	338
+#define SKEW_CHAR_OPT		339
+#define EXTRA_SKEW_OPT		340
 
 #define AUTOMATIC_OPT		341
 #define FONT_NAME_OPT		342
@@ -163,6 +165,8 @@
     { "alternates-filter", 0, ALTERNATES_FILTER_OPT, Clp_ArgString, 0 },
     { "space-factor", 0, SPACE_FACTOR_OPT, Clp_ArgDouble, 0 },
     { "math-spacing", 0, MATH_SPACING_OPT, 0, Clp_Negate },
+    { "skew-char", 0, SKEW_CHAR_OPT, CHAR_OPTTYPE, 0 },
+    { "extra-skew", 0, EXTRA_SKEW_OPT, Clp_ArgInt, 0 },
     
     { "pl", 'p', PL_OPT, 0, 0 },
     { "virtual", 0, VIRTUAL_OPT, 0, Clp_Negate },
@@ -235,6 +239,8 @@
 static double minimum_kern = 2.0;
 static double space_factor = 1.0;
 static bool math_spacing = false;
+static int extra_skew = 0;
+static int skew_char = -1;
 
 static String out_encoding_file;
 static String out_encoding_name;
@@ -292,6 +298,7 @@
   -k, --min-kern=N             Omit kerns with absolute value < N [2.0].\n\
       --space-factor=F         Scale wordspace by a factor of F.\n\
       --design-size=SIZE       Set font design size to SIZE.\n\
+      --extra-skew=AMT         Add AMT to the kerning with the skew character.\n\
 \n");
     printf("\
 Encoding options:\n\
@@ -309,6 +316,7 @@
       --include-alternates=PAT Same, but cumulative.\n\
       --exclude-alternates=PAT Ignore alternate characters matching PAT.\n\
       --clear-alternates       Clear included/excluded alternates.\n\
+      --skew-char=CHAR         Set the skew character to CHAR.\n\
 \n");
     printf("\
 Automatic mode options:\n\
@@ -476,10 +484,33 @@
     }
 }
 
+static int
+get_x_height(const Cff::Font *family_cff, const OpenType::Cmap &cmap,
+             const Transform &font_xform)
+{
+    // XXX what if 'x', 'm', 'z' were subject to substitution?
+    int xheight = 1000;
+    int bounds[4];
+    int width;
+    static const int xheight_unis[] = { 'x', 'm', 'z', 0 };
+    for (const int *x = xheight_unis; *x; x++)
+	if (char_bounds(bounds, width, family_cff, cmap, 'x', font_xform) && bounds[3] < xheight)
+	    xheight = bounds[3];
+    return xheight;
+};
+
+static double
+get_slant(const Cff::Font *family_cff)
+{
+    double val;
+    (void) family_cff->dict_value(Efont::Cff::oItalicAngle, &val);
+    return -tan(val * M_PI / 180.0);
+};
+
 static void
 output_pl(const Metrics &metrics, const String &ps_name, int boundary_char,
 	  const OpenType::Font &family_otf, const Cff::Font *family_cff,
-	  bool vpl, FILE *f)
+	  bool vpl, bool output_ligkern, FILE *f)
 {
     // XXX check DESIGNSIZE and DESIGNUNITS for correctness
 
@@ -513,8 +544,7 @@
     double du = (design_units == 1000 ? 1. : design_units / 1000.);
     
     double val;
-    (void) family_cff->dict_value(Efont::Cff::oItalicAngle, &val);
-    double actual_slant = -tan(val * M_PI / 180.0) + slant;
+    double actual_slant = get_slant(family_cff) + slant;
     if (actual_slant)
 	fprintf(f, "   (SLANT R %g)\n", actual_slant);
 
@@ -536,12 +566,7 @@
 	}
     }
 
-    // XXX what if 'x', 'm', 'z' were subject to substitution?
-    int xheight = 1000;
-    static const int xheight_unis[] = { 'x', 'm', 'z', 0 };
-    for (const int *x = xheight_unis; *x; x++)
-	if (char_bounds(bounds, width, family_cff, cmap, 'x', font_xform) && bounds[3] < xheight)
-	    xheight = bounds[3];
+    int xheight = get_x_height(family_cff, cmap, font_xform);
     if (xheight < 1000)
 	fprint_real(f, "   (XHEIGHT", xheight, du);
     
@@ -594,39 +619,42 @@
     // finally, BOUNDARYCHAR
     glyph_ids.push_back("BOUNDARYCHAR");
 
-    // LIGTABLE
-    fprintf(f, "(LIGTABLE\n");
-    Vector<int> lig_code2, lig_outcode, lig_context, kern_code2, kern_amt;
-    // don't print KRN x after printing LIG x
-    uint32_t used[8];
-    for (int i = 0; i <= 256; i++)
-	if (metrics.glyph(i) && minimum_kern < 10000) {
-	    int any_lig = metrics.ligatures(i, lig_code2, lig_outcode, lig_context);
-	    int any_kern = metrics.kerns(i, kern_code2, kern_amt);
-	    if (any_lig || any_kern) {
-		StringAccum kern_sa;
-		memset(&used[0], 0, 32);
-		for (int j = 0; j < lig_code2.size(); j++) {
-		    kern_sa << "   (" << lig_context_str(lig_context[j])
-			    << ' ' << glyph_ids[lig_code2[j]]
-			    << ' ' << glyph_ids[lig_outcode[j]]
-			    << ')' << glyph_comments[lig_code2[j]]
-			    << glyph_comments[lig_outcode[j]] << '\n';
-		    used[lig_code2[j] >> 5] |= (1 << (lig_code2[j] & 0x1F));
-		}
-		for (Vector<int>::const_iterator k2 = kern_code2.begin(); k2 < kern_code2.end(); k2++)
-		    if (!(used[*k2 >> 5] & (1 << (*k2 & 0x1F)))) {
-			double this_kern = kern_amt[k2 - kern_code2.begin()];
-			if (fabs(this_kern) >= minimum_kern)
-			    kern_sa << "   (KRN " << glyph_ids[*k2]
-				    << " R " << real_string(this_kern, du)
-				    << ')' << glyph_comments[*k2] << '\n';
-		    }
-		if (kern_sa)
-		    fprintf(f, "   (LABEL %s)%s\n%s   (STOP)\n", glyph_ids[i].c_str(), glyph_comments[i].c_str(), kern_sa.c_str());
-	    }
-	}
-    fprintf(f, "   )\n");
+    if (output_ligkern)
+    {
+      // LIGTABLE
+      fprintf(f, "(LIGTABLE\n");
+      Vector<int> lig_code2, lig_outcode, lig_context, kern_code2, kern_amt;
+      // don't print KRN x after printing LIG x
+      uint32_t used[8];
+      for (int i = 0; i <= 256; i++)
+          if (metrics.glyph(i)) {
+              int any_lig = metrics.ligatures(i, lig_code2, lig_outcode, lig_context);
+              int any_kern = metrics.kerns(i, kern_code2, kern_amt);
+              if (any_lig || any_kern) {
+                  StringAccum kern_sa;
+                  memset(&used[0], 0, 32);
+                  for (int j = 0; j < lig_code2.size(); j++) {
+                      kern_sa << "   (" << lig_context_str(lig_context[j])
+                              << ' ' << glyph_ids[lig_code2[j]]
+                              << ' ' << glyph_ids[lig_outcode[j]]
+                              << ')' << glyph_comments[lig_code2[j]]
+                              << glyph_comments[lig_outcode[j]] << '\n';
+                      used[lig_code2[j] >> 5] |= (1 << (lig_code2[j] & 0x1F));
+                  }
+                  for (Vector<int>::const_iterator k2 = kern_code2.begin(); k2 < kern_code2.end(); k2++)
+                      if (!(used[*k2 >> 5] & (1 << (*k2 & 0x1F)))) {
+                          double this_kern = kern_amt[k2 - kern_code2.begin()];
+                          if (fabs(this_kern) >= minimum_kern)
+                              kern_sa << "   (KRN " << glyph_ids[*k2]
+                                      << " R " << real_string(this_kern, du)
+                                      << ')' << glyph_comments[*k2] << '\n';
+                      }
+                  if (kern_sa)
+                      fprintf(f, "   (LABEL %s)%s\n%s   (STOP)\n", glyph_ids[i].c_str(), glyph_comments[i].c_str(), kern_sa.c_str());
+              }
+          }
+      fprintf(f, "   )\n");
+    }
     
     // CHARACTERs
     Vector<Setting> settings;
@@ -685,7 +713,7 @@
 static void
 output_pl(const Metrics &metrics, const String &ps_name, int boundary_char,
 	  const OpenType::Font &family_otf, const Cff::Font *family_cff,
-	  bool vpl, String filename, ErrorHandler *errh)
+	  bool vpl, bool output_ligkern, String filename, ErrorHandler *errh)
 {
     if (no_create)
 	errh->message("would create %s", filename.c_str());
@@ -693,7 +721,7 @@
 	if (verbose)
 	    errh->message("creating %s", filename.c_str());
 	if (FILE *f = fopen(filename.c_str(), "w")) {
-	    output_pl(metrics, ps_name, boundary_char, family_otf, family_cff, vpl, f);
+	    output_pl(metrics, ps_name, boundary_char, family_otf, family_cff, vpl, output_ligkern, f);
 	    fclose(f);
 	} else
 	    errh->error("%s: %s", filename.c_str(), strerror(errno));
@@ -859,7 +887,8 @@
 	    sa << (i ? "\n%" : "%") << hex_digits[(i >> 4) & 0xF] << '0' << '\n' << ' ';
 	else if ((i & 0x7) == 0)
 	    sa << '\n' << ' ';
-	if (int g = glyphs[i])
+	int g = glyphs[i];
+	if (g > 0 && g < glyph_names.size())
 	    sa << ' ' << '/' << glyph_names[g];
 	else
 	    sa << " /.notdef";
@@ -933,7 +962,7 @@
 static void
 output_tfm(const Metrics &metrics, const String &ps_name, int boundary_char,
 	   const OpenType::Font &family_otf, const Cff::Font *family_cff,
-	   String tfm_filename, String vf_filename, ErrorHandler *errh)
+	   String tfm_filename, String vf_filename, bool output_ligkern, ErrorHandler *errh)
 {
     String pl_filename;
     int pl_fd = temporary_file(pl_filename, errh);
@@ -949,7 +978,7 @@
 	if (verbose)
 	    errh->message("writing %s to temporary file", (vpl ? "VPL" : "PL"));
 	FILE *f = fdopen(pl_fd, "w");
-	output_pl(metrics, ps_name, boundary_char, family_otf, family_cff, vpl, f);
+	output_pl(metrics, ps_name, boundary_char, family_otf, family_cff, vpl, output_ligkern, f);
 	fclose(f);
     }
 
@@ -1008,30 +1037,26 @@
 	if (output_flags & G_BINARY) {
 	    String tfm = getodir(O_TFM, errh) + "/" + font_name + ".tfm";
 	    String vf = getodir(O_VF, errh) + "/" + font_name + ".vf";
-	    output_tfm(metrics, ps_name, boundary_char, family_otf, family_cff, tfm, vf, errh);
+	    output_tfm(metrics, ps_name, boundary_char, family_otf, family_cff, tfm, vf, true, errh);
 	} else {
 	    String outfile = getodir(O_VPL, errh) + "/" + font_name + ".vpl";
-	    output_pl(metrics, ps_name, boundary_char, family_otf, family_cff, true, outfile, errh);
+	    output_pl(metrics, ps_name, boundary_char, family_otf, family_cff, true, true, outfile, errh);
 	    update_odir(O_VPL, outfile, errh);
 	}
 	metrics.make_base(257);
     }
 
     // output metrics
-    double save_minimum_kern = minimum_kern;
-    if (need_virtual)
-	minimum_kern = 100000;
     if (!(output_flags & G_METRICS))
 	/* do nothing */;
     else if (output_flags & G_BINARY) {
 	String tfm = getodir(O_TFM, errh) + "/" + base_font_name + ".tfm";
-	output_tfm(metrics, ps_name, boundary_char, family_otf, family_cff, tfm, String(), errh);
+	output_tfm(metrics, ps_name, boundary_char, family_otf, family_cff, tfm, String(), !need_virtual, errh);
     } else {
 	String outfile = getodir(O_PL, errh) + "/" + base_font_name + ".pl";
-	output_pl(metrics, ps_name, boundary_char, family_otf, family_cff, false, outfile, errh);
+	output_pl(metrics, ps_name, boundary_char, family_otf, family_cff, false, !need_virtual, outfile, errh);
 	update_odir(O_PL, outfile, errh);
     }
-    minimum_kern = save_minimum_kern;
 
     // print DVIPS map line
     if (errh->nerrors() == 0 && (output_flags & G_PSFONTSMAP)) {
@@ -1272,6 +1297,9 @@
     // encode boundary glyph at 256; pretend its Unicode value is '\n'
     metrics.encode(256, '\n', metrics.boundary_glyph());
 
+    if (skew_char >= 0)
+        metrics.encode(skew_char, '\n', metrics.skew_glyph());
+
     // maintain statistics about features
     HashMap<uint32_t, int> feature_usage(0);
 
@@ -1326,18 +1354,33 @@
     // apply math letterspacing, if any
     if (math_spacing) {
 	Transform font_xform;
-	CharstringBounds boundser(font_xform);
 	int bounds[4], width;
+
+        double actual_slant = get_slant(font) + slant;
+	int x_height = get_x_height(font, cmap, font_xform);
+
 	for (int code = 0; code < 256; code++) {
 	    int g = metrics.glyph(code);
 	    if (g != 0 && g != Metrics::VIRTUAL_GLYPH && code != boundary_char) {
-		if (char_bounds(bounds, width, font, cmap, code, font_xform)) {
-		    int left_sb = (bounds[0] < 0 ? -bounds[0] : 0);
+		if (Efont::CharstringBounds::bounds(font_xform, font->glyph_context(g), bounds, width)) {
+		    // increase sidebearings
+		    int left_sb  = (bounds[0] < 0 ? -bounds[0] : 0);
 		    int right_sb = (bounds[2] > width ? bounds[2] - width : 0);
-		    metrics.add_single_positioning(code, left_sb, 0, left_sb + right_sb);
+		    metrics.add_single_positioning(code, left_sb, 0, left_sb);
+
+		    if (skew_char >= 0) {
+		        // compute accent skew
+		        int height = bounds[3];
+		        int skew = (int)(actual_slant * (height > x_height ? height - 0.5*x_height : 0.5*x_height))
+                                      + left_sb - right_sb
+                                      + extra_skew;
+
+                        if (skew != 0)
+			    metrics.add_kern(code, skew_char, (int)skew);
+                    }
 		}
 	    }
-	}
+        }
     }
 
     // reencode right components of boundary_glyph as boundary_char
@@ -1556,6 +1599,14 @@
 	    if (space_factor != 1)
 		usage_error(errh, "space factor specified twice");
 	    space_factor = clp->val.d;
+	    break;
+
+	  case SKEW_CHAR_OPT:
+	    skew_char = clp->val.i;
+	    break;
+
+	  case EXTRA_SKEW_OPT:
+	    extra_skew = clp->val.i;
 	    break;
 
 	  case MATH_SPACING_OPT:

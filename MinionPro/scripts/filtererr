#!/usr/bin/perl
# Summarize maketfm's errors/warnings
#
# [r] I had to round some heights/depths (pltotf, vptovf); maxima at end
# [b] warning: no boundary character (otftotfm)
# [e] has no encoding, ignoring kern removal; summary of characters at end
use strict;
use warnings;
use List::Util qw(max);

my %errors = ();

sub flush_errors {
    print "]" if keys %errors;
    %errors = ();
}
sub print_literal {
    my $literal = shift;
    flush_errors() if length $literal;
    print $literal;
}
sub print_error {
    my $e = shift;
    print "[" unless keys %errors;
    if (!exists $errors{$e}) {
	print $e;
	$errors{$e}++;
    }
    return "";
}

$| = 1;

my %rounded = (
    heights => 0,
    depths => 0,
);
my %no_encoding = ();

while (<STDIN>) {
    s{(.*?)I had to round some (\w+) by ([\d.]+) units\.\n}[
	$rounded{$2} = max $rounded{$2}, $3;
	print_literal($1);
	print_error("r");
    ]e;
    s{(.*?)otftotfm: warning: no boundary character.*?\n}[
	print_literal($1);
        print_error("b");
    ]e;
    s{(.*?)otftotfm: \(You may want to try.*?\)\n}[
	print_literal($1);
        print_error("b");
    ]e;
    s{(.*?)otftotfm: (\./enc/[\w-]+\.enckern):\d+: warning: '(\w+)' has no encoding, ignoring kern removal\n}[
	print_literal($1);
	$no_encoding{$2}{$3}++;
	print_error("e");
    ]e;
    print_literal($_);
}
flush_errors();

foreach (sort keys %rounded) {
    printf "I had to round some $_ by %.7f units.\n", $rounded{$_};
}
foreach my $enc_file (sort keys %no_encoding) {
    print "$enc_file: warning: The following glyphs had no encoding: ";
    print join ", ", sort keys %{$no_encoding{$enc_file}};
    print ".\n";
}
